[{"title":"mysql之索引入门","date":"2019-03-06T02:23:49.000Z","path":"2019/03/06/mysql之索引入门/","text":"​ 在mysql中，所有列类型数据都能被索引，使用索引是改进mysql查询操作性能的最好办法，是数据库优化的重要手段之一。 索引的特点 一个表最多可有16个索引，最大索引长度是256字节，尽管这可以在编译MySQL时被改变。 对于 CHAR 和 VARCHAR 列,你可以索引列的前缀。这更快并且比索引整个列需要较少的磁盘空间。对于 BLOB 和 TEXT 列，你必须索引列的前缀，你不能索引列的全部。 MySQL 能在多个列上创建索引，一个索引可以由最多15个列组成。（在CHAR和VARCHAR列上，你也可以使用列的前缀作为一个索引的部分） ISAM 表和 MyISAM 表之间的差别： 索引特点|ISAM 表|MyISAM 表 索引特点 ISAM 表 MyISAM NULL 值 不允许 允许 BLOB 和 TEXT 值 不能索引 只能索引列的前缀 每个表中的索引数 16 32 每个索引中的列数 16 16 最大索引行尺寸 256字节 500字节 索引有如下几种情况： INDEX 索引：通常意义的索引，某些情况下 KEY 是它的一个同义词，索引的列可以包含重复的值。 UNIQUE 索引：唯一索引，保证了列不包含重复的值，对于多列唯一索引，它保证值得组合不重复。 PRIMARY KEY 索引：和UNIQUE索引类似，可以理解为特殊的 UNIQUE 索引。一个表中只能包含一个PRIMARY KEY，PRIMARY KEY 索引不允许列为空值。 创建和删除索引1. 使用 Alter Table 和 Create Index 语句12345ALTER TABLE tb_name ADD INDEX index_name(column_list);ALTER TABLE tb_name ADD UNIQUE index_name(column_list);ALTER TABLE tb_name ADD PRIMARY KEY index_name(column_list); tb_name 是要添加索引的表名，index_name 是创建的索引名，column_list是列名集合,多个列名使用逗号分隔。 同样，也可以使用 ALTER TABLE 语句加 DROP 操作符删除索引： 123ALTER TABLE tb_name DROP INDEX index_name;ALTER TABLE tb_name DROP PRIMARY KEY; ​ 上面第一条语句可以删除各类型索引，第二条语句只在删除 PRIMARY KEY 作用。如果没有明确地创建作为 PRIMARY KEY 的索引，但该表具有一个或多个UNIQUE 索引，则 MySQL将删除 UNIQUE 索引的第一个。 ​ 索引依赖于列而存在，如果从表中删除了列，则索引会受到影响。如果所删除的列作为索引的组成部分，则该列会从索引中删除；如果索引的所有列被删除，那么该索引也会被隐式删除。 2. 使用CREATE/DROP INDEX 创建索引CREATE INDEX 是在 MySQL3.23版引入的。标准语法格式如下： 123CREATE UNIQUE INDEX index_name ON tb_name(column_list);CREATE INDEX index_name ON tb_name(column_list); 注意：不能用 CREATE INDEX 创建PRIMARY KEY 索引。 DROP INDEX 是在 3.22 中引入的，标准语法格式如下： 1DROP INDEX index_name ON tb_name; 在创建表时指定索引 要想创建新表时同时创建索引，指定索引的语句语法如下： 12345678CREATE table tb_name(... INDEX index_name(column_list), key index_name(column_list), UNIQUE index_name(column_list), PRIMARY KEY index_name(column_list), ...); 与 ALTER TABLE 一样，索引名对于 INDEX 和 UNIQUE 都是可选的，如果未给出，MySQL将为其选一个。 当索引的列为单列时，也可以在列定义后指定索引，如下： 12345CREATE table tb_name( column_name type_name PRIMARY KEY, column_name type_name UNIQUE ...); 上面 PRIMARY KEY 的指定也可等价于：PRIMARY KEY(column_name)。 3. 对串列的前缀进行索引 在 CREATE TABLE 语句中可以某个串列的前缀进行索引（列值左边的n个字符）。 对某个列的前缀进行索引，上面 colum_list 的指定中，column_name改为column_name(n)。如下面的语句： 12345CREATE TABLE tb_name( name CHAR(30), address CHAR(60), INDEX(name(10),adress(20))) 检查表的索引1SHOW INDEX FROM tb_name; THE END! 本文转自百度文库——MySQL完全手册。","tags":[{"name":"mysql","slug":"mysql","permalink":"https://blogs.yumiaoxia.com/tags/mysql/"},{"name":"索引","slug":"索引","permalink":"https://blogs.yumiaoxia.com/tags/索引/"},{"name":"数据库优化","slug":"数据库优化","permalink":"https://blogs.yumiaoxia.com/tags/数据库优化/"}]},{"title":"理解mysql之内连接，外连接，全连接","date":"2019-03-04T06:27:24.000Z","path":"2019/03/04/mysql-lianjie/","text":"一. 前言SQL语法，select 语句可以通过连接多个表来检索数据。表与表之间的连接关系可分为内链接，外连接和全连接。我们最常用的是内连接；外连接分为左外连接和右外连接；全连接是一般很少用，它查询的结果集记录数是查询的各个表的记录数的乘积。下面详细介绍这几种连接。 我们创建两个标为例子： 学生（student）表： 1234 create table student( id int primary key, name varchar(20) not null)engine=Innodb default charset=utf8mb4; 课程（course）表: 1234 create table course( id int primary key, cname varchar(30) not null)engine = INNODB default charset = utf8mb4; 学生课程关系表： 1234create table students_courses(cid int REFERENCES course(id),sid int REFERENCES student(id)); 插入以下数据： 12345insert into student values(1,\"Timmy\"),(2,\"Smith\"),(3,\"Jhon\"),(4,\"Petter\");insert into course values(1,'English'),(2,'Math'),(3,'Music');insert into course values(1,2),(2,3),(1,1),(2,1); 二. 内连接内连接是最广泛使用的连接方式，语法标准格式是： 1select property1,property2,... from t1,t2,... where expr; 例1：查询所有学生和他们选修的课程 1select s.name,c.cname from student s,course c,students_courses sc where s.id = sc.sid and sc.cid = c.id; 显示结果如下: | name | cname | |-------|---------| | Smith | English | | Jhon | Math | | Timmy | English | | Timmy | Math | 三. 左连接、右连接​ 左连接和右连接统称为外连接，左连接也可叫为左外连接，右连接也可叫为右外连接。 ​ 左连接不仅匹配类似前面的行记录，而且还显示左边的表有而右边的表中五匹配的行，对于这样的行，右边表不匹配的列均被显示为NULL。这样每一条匹配的行都从左边的表被选出，如果右边表有一个匹配的行，则被选中，如果不匹配，行仍然被选中，只不过，右边表响应的列在结果集中均设为null。也就是，LEFT JOIN 强制包含左边表的每一行，而不管右边表是否匹配。 标准语法： 1select property1,property2,... from left_table left join right_table on expr; 例2： 1select * from student s left join course c on s.id=c.id; 结果如下： | id | name | id | cname | |----|--------|------|---------| | 1 | Timmy | 1 | English | | 2 | Smith | 2 | Math | | 3 | Jhon | 3 | Music | | 4 | Petter | NULL | NULL | ​ 上面的结果，即用左边表的每一行与右边表匹配，如果匹配，则选择到结果集中，如果没有匹配，则结果集中右边表响应的列置为NULL。 为了进一步理解，举出一个有点奇怪的例子，例3： 1select * from student s left join course c on s.id=1 结果显示： | id | name | id | cname | |----|--------|------|---------| | 1 | Timmy | 1 | English | | 1 | Timmy | 2 | Math | | 1 | Timmy | 3 | Music | | 2 | Smith | NULL | NULL | | 3 | Jhon | NULL | NULL | | 4 | Petter | NULL | NULL | ​ 结果最后三行似乎是你不希望看到的。然而如果 只有 ON 子句的条件，那么左边表的每一行都会返回，只是如果没有匹配到右边表（虽然本例没有约束course表）,那结果集中右边表的记录值为NULL。 ​ 理解了了上面的内容，那么我们可以结合 WHERE 子句使用，这是一个非常有用的技巧。使用 IS NULL 和 IS NOT NULL操作符可以筛选出我们想要的记录。 例4：基于例2的改造 1select * from student s left join course c on s.id=c.id where c.id is not null; 结果显示： | id | name | id | cname | |----|-------|----|---------| | 1 | Timmy | 1 | English | | 2 | Smith | 2 | Math | | 3 | Jhon | 3 | Music | ​ 这结果和【select * from student s,course c where s.id=c.id】 的结果是一样的。 ​ 右连接和左连接的原理是一样的，举一反三相信也就很容易理解了。 四. 全连接全连接也叫笛卡尔积连接，看下面的一个例子。 例5-1： 1select * from student,course; | id | name | id | cname | |----|--------|----|---------| | 1 | Timmy | 1 | English | | 1 | Timmy | 2 | Math | | 1 | Timmy | 3 | Music | | 2 | Smith | 1 | English | | 2 | Smith | 2 | Math | | 2 | Smith | 3 | Music | | 3 | Jhon | 1 | English | | 3 | Jhon | 2 | Math | | 3 | Jhon | 3 | Music | | 4 | Petter | 1 | English | | 4 | Petter | 2 | Math | | 4 | Petter | 3 | Music | 例5-2： 1select * from course，student; | id | cname | id | name | |----|---------|----|--------| | 1 | English | 1 | Timmy | | 2 | Math | 1 | Timmy | | 3 | Music | 1 | Timmy | | 1 | English | 2 | Smith | | 2 | Math | 2 | Smith | | 3 | Music | 2 | Smith | | 1 | English | 3 | Jhon | | 2 | Math | 3 | Jhon | | 3 | Music | 3 | Jhon | | 1 | English | 4 | Petter | | 2 | Math | 4 | Petter | | 3 | Music | 4 | Petter | 可以看到，结果集中3*4=12行，这就是全连接的结果，输出结果集的字段顺序是按 FROM 子句后面的表来显示的。 全连接一般可以用在预测结果组合的可能性，例如下棋的下一步布局，雌雄繁殖匹配等等。","tags":[{"name":"mysql","slug":"mysql","permalink":"https://blogs.yumiaoxia.com/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://blogs.yumiaoxia.com/tags/数据库/"}]},{"title":"Hello World","date":"2019-03-04T02:54:48.593Z","path":"2019/03/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"github-hexo搭建好看的个人自由博客","date":"2019-03-02T06:05:42.000Z","path":"2019/03/02/github-hexo搭建好看的个人自由博客/","text":"前言一. 前言本文介绍怎么利用github+hexo在windows下搭建自己的博客。小编苦苦撕逼两天总结了这篇实战经验。 先看体验效果：https://blogs.yumiaoxia.com 特点： 全是静态文件，访问速度快 免费方便，不用花钱就可以搭建一个自由的个人博客，不需要服务器 可以绑定自己的域名 数据安全，基于github的版本管理，可以恢复 博客内容可以轻松打包，迁移 由于基于GitHub page，服务器在国外，访问速度受影响 博客内容使用html或者mardown编写，需要作者具备基础 IT 知识 博客功能（评论、登录等）主要受限于主题，个性化配置需要一定技术功底 1.1 准备工作 注册一个github账号 安装了git客户端 安装nodeJs、npm环境 1.2 大致流程 搭建github博客 配置SSH key 安装、配置hexo 使用主题 写博客、发布 二. 搭建github博客2.1 创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了。注意用户名必需都是小写，每个账户只能一个这样可以使用域名访问的仓库。创建的时候指定一个README.md文件，用来显示创建空间后首页的展示内容 创建成功后，在仓库里点击右边的settings,往下拉，可以看到 第一个红框说明可以使用该url访问你的github博客，第二个红框中的按钮可以点击进去选择一个主题样式。 2.2 绑定域名这是一个可选步骤，根据个人喜欢可以绑定一个域名，如果不进行这一步，则你的的博客还是按“https://用户名.github.io”访问。 首先注册一个域名，腾讯云的域名注册地址点击这里 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，经测试 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 三. 配置SSH key直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 检查本机已存在的ssh密钥 1$ cd ~/.shh 如果提示”no such file or directory”,说明以前在本机没有配置过，这是，利用ssh工具生成: 1$ ssh-keygen -t rsa -C \"邮件地址\" #注意参数C为大写 然后，连续默认3次就可以了，打开用户目录下 .ssh/id_rsa.pub文件，editPlus打开复制里面内容。然后进入 gitbub个人主页》settings》SSH and GPG keys》new SSH key，按下图粘贴拷贝的内容 最后测试是否成功： 1$ ssh -T git@github.com #邮箱地址不用改 如果提示“Hi yumiaoxia! You’ve successfully authenticated, but GitHub does not provide shell access.”说明SSH配置成功。 需要在Git中配置全局变量：你的用户名、密码。在git命令客户端窗口执行： 12$ git config --global user.name \"用户名\"$ git config --global user.email \"邮箱地址\" 四. 安装、配置hexo4.1 hexo简介Hexo是一个简单，轻量、快速、强大的基于 Github Pages的博客发布工具，支持Mardown语法，有众多优秀插件和主题 官网：http://hexo.io 4.2 使用前注意事项 有些命令受限于git，所以建议以下命令都是用Git bash 工具完成。 hexo初始化后有两种_config.yml文件，一个是根目录下的，一个是各个heme下面的 先新建一个目录文件夹hexo，以下命令都在该文件夹下执行 4.3 安装及初始化安装： 1$ npm install -g hexo 初始化： 1$ hexo init 这步命令执行完，会在hexo根目录下生成一些列固定文件及文件夹 4.4 配置 如上图，我们看到根目录有一个配置文件_config.yml,在EditPlus工具中打开，我们需要对里面的一些内容进行设置。设置项可以参考官方文档，例如使用语言，网站名字，作者等。 我们要将编写的网页能上传到 Github上面，需要在该配置文件末尾添加： 1234deploy: type: git repository: git@github.com:yumiaoxia/yumiaoxia.github.io.git branch: master 我们要能推送到github上，还需要一个安装插件 1$ npm install hexo-deployer-git --save 完成上面工作，基础配置已经Ok，我们可以测试以下效果 依次执行 12$ hexo g # 将所有文件打包到根目录public下，这个过程会把md文件转换为html文件 == hexo generator$ hexo s # 启动服务器 提示以下信息，服务成功启动 打开浏览器，输入“http://localhost:4000&quot; 如图界面已经正常显示，可以将博客推送到Github上面了 1$ hexo d 之后，你就可以在 你的用户名.github.io上看到同样的效果，到这里Hexo的基本搭建算高成功了。 4.5 一些其他常用命令1234567$ hexo init # hexo环境初始化$ hexo g # hexo 构建博客项目$ hexo s # hexo 启动本地服务$ hexo d # 推送到github，使用该命令需要安装git插件$ hexo new '文章' # 新建一篇文章，source目录下按日期生成一个扩展名（.md）的文件，可以使用markdown语法编辑你想发布的内容，构建时会自动转换html文件在浏览器显示$ hexo new page '页面名字' #该命令会生成一个目录，目录下有一个index的页面$ hexo clean # 清空缓存，一般在重新构建项目前使用该命令 五. 使用主题hexo 默认是使用 landscape主题，个人感觉比较丑，简陋。官网上可以找到大量的主题供我们选择，我们可以点击预览，相信总有一款高大上符合你心意的。 官网提供的主题模板林林总总，有的比较简洁，配置简单；有的功能健壮，但配置稍微复杂，没有花一些时间摸索是不行的，百度给出来的教程就大概是（yilia,next,jekyll…)这几种。 针对程序员来说，一般比较喜欢模板层次分明，代码高亮，功能强大的主题，这里推荐以下几种： Fan： 界面精美，整体颜色黑色带些透明，星光动画。代码高亮，目录显示，一键置顶，上下文章切换，支持搜索，浏览统计，不支持评论系统。总体来说，确实一款不错的主题，但是该主题作者没有提供较为详细的配置教程，还是需要使用者画一些精力，时间配置的 snark：该主题视觉上也是非常丰富的，文章黑底白字，代码看起来也比较酷炫，支持搜索，评论系统，一键置顶，上下文章切换，浏览统计，不支持目录，总体来说也是一款非常不错的主题。 black-blue: 该主题以黑灰色为主调，外观还是蛮漂亮的，支持上下文章切换，文章目录，搜索，评论系统，最大的特点是不同的标签以不同颜色区分，代码高亮显示行号，支持评论，登录，文章列表，也是一款不错的主题选择 起始还有一些满优秀的主题，这里限于篇幅，就介绍这几款。下面就以snark为例，介绍怎么配置使用。 在官网主题列表中搜索“snark”，点击图中连接 拷贝项目路径，粘贴在Git bash中，使用git clone下载在“themes/snark”下 1$ git clone https://github.com/Litreily/hexo-theme-snark.git themes/snark 然后阅读README.md文件，根据文件提示操作 首先，提示我们安装两个插件，我们照着执行 12$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 记得，安装玩插件之后需要到插件列表中找到该插件，看看该插件的使用刚发，有可能主题的发布者会忽略提示，导致你的配置失败。 在sass插件下，可以看到需要的配置项，直接拷贝到 根目录/_config.yml中 然后提示我们禁用原本的代码高亮的配置，我们照着操作 另外需要的一些插件： 123$ npm install hexo-generator-feed --save$ npm install hexo-generator-search --save$ npm install hexo-generator-sitemap --save 根目录配置文件加入如下配置 123456789101112131415161718192021222324## snark所需配置node_sass: outputStyle: nested precision: 5 sourceComments: false ## snark所需配置feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: icon.png ## snark所需配置search: path: search.xml field: post content: true ## snark所需配置sitemap: path: sitemap.xml 主题配置文件，评论系统（使用第三方评论系统，需要先到learnclound注册） 其他一些通用配置（主题发布没提示） 主配置下修改 1theme: snark 安装的插件需要指定 1234Plugins: - hexo-generator-search - hexo-generator-feed - hexo-generator-sitemap 语言。需要根据主题目录下的语言包指定，snark没有，这里指定通用的两种中文 123language: - zh-CN - zh-Hans 其他一些配置，如目录，友链等 完成后，使用如下命令查看效果 123$ hexo clean #清除缓存$ hexo g #构建项目$ hexo s #开启服务 打开浏览器查看效果 ps: 本教程第五章只是其中一个主题安装的示范,而文章开头的预览效果使用的主题是BlueLake（安装教程看这里），另外读者可根据自己的喜好选择安装，只要细心一些，相信你也可以成功的😊！","tags":[{"name":"hexo","slug":"hexo","permalink":"https://blogs.yumiaoxia.com/tags/hexo/"},{"name":"工具","slug":"工具","permalink":"https://blogs.yumiaoxia.com/tags/工具/"},{"name":"个人博客","slug":"个人博客","permalink":"https://blogs.yumiaoxia.com/tags/个人博客/"}]},{"title":"my-first-blog ","date":"2019-03-02T05:18:47.000Z","path":"2019/03/02/my-first-blog/","text":"这是我第一篇文章","tags":[]}]